import debug_ext::(debug)
import std::fmt::(Format, Formatter)
import std::stdio::(STDOUT)
import std::net::socket
import std::net::ip
import std::io
import std::iter::(Iter)
import std::string::(StringBuffer, ToString)
import option_ext
import uni::(Uni)
import line_reader::(LineReader)
import route::(RouteMatcher)
import request::(Method, HttpRequest)
import response::(HttpStatus, HttpResponse)

trait pub Handler: Uni[Handler] {
  fn handle(request: ref HttpRequest) -> HttpResponse
}

class NotFoundHandler {}

impl Uni[Handler] for NotFoundHandler {
  fn pub clone_to_uni -> uni NotFoundHandler {
    recover NotFoundHandler {}
  }

  fn pub move into_referrable -> NotFoundHandler {
      self
  }
}

impl Handler for NotFoundHandler {
  fn handle(request: ref HttpRequest) -> HttpResponse {
    let response = HttpResponse.new(HttpStatus.NOT_FOUND)
    response.body = "Not found"
    response
  }
}

class async RouteMapper {
  let @routes: Array[(RouteMatcher, Handler)]

  fn static new -> RouteMapper {
    RouteMapper {
      @routes = recover []
    }
  }

  fn pub async mut add_route(route: uni RouteMatcher, handler: uni Handler) {
    @routes.push((route, handler))
  }

  fn pub async mut match(request: uni HttpRequest, channel: Channel[Option[uni Handler]]) {
    debug("Matching")
    let iter = @routes.iter
    let request = request.non_uni
    let mut result = recover Option.None
    debug("Looping")
    loop {
      debug("ITER")
      match iter.next {
        case None -> break
        case Some((route, handler)) if route.match(request) -> {
          let uni_handler = handler.clone_to_uni
          result = recover Option.Some(uni_handler)
          break
        }
        case _ -> nil
      }
    }
    debug("Sending result")
    channel.send(result)
  }
}

class async SocketHandler {
  let @connection: socket::TcpClient
  let @routes: RouteMapper

  fn static new(connection: uni socket::TcpClient, routes: RouteMapper) -> SocketHandler {
    SocketHandler {
      @connection = connection
      @routes = routes
    }
  }
  fn async mut handle {
    let request = match HttpRequest.parse(@connection) {
      case Ok(val) -> val
      case Error(error) -> {
        debug(error)
        match error.to_response.write(@connection) {
          case Ok(_) -> nil
          case Error(error) -> debug(error)

        }
        return
      }
    }

    debug(request)
    let channel = Channel.new(size: 1)
    debug("Got channel")
    @routes.match(request.uni_clone, channel)
    debug("sent match route")
    let handler: Handler = channel.receive.unwrap_or(recover NotFoundHandler {}).into_referrable
    debug("GOT HANDLER")

    let response: HttpResponse = handler.handle(request)
    debug(response)
    match response.write(@connection) {
      case Ok(_) -> nil
      case Error(error) -> debug(error)
    }
  }
}


class pub WebApp {
  let @listener: uni socket::TcpServer
  let @port: Int
  let @routes: RouteMapper

  # Create a  new WebApp that will connect to the given
  # address and port when `listen()` is called
  fn pub static new(address: String, port: uni Int) -> Result[WebApp,  io::Error] {

    let ip = recover ip::IpAddress.parse(address).unwrap
    let listener =  recover try socket::TcpServer.new(recover ip, port)

    Result.Ok(
      WebApp {
        @port = port
        @listener = listener
        @routes = RouteMapper.new
      }
    )
  }

  fn pub mut add_route(route: uni RouteMatcher, handler: uni Handler) {
    @routes.add_route(route, handler)
  }

  fn pub move listen() {
    STDOUT.new.print("Listening on port {@port.to_string}")
    loop {
      let connection = recover @listener.accept.unwrap
      debug("GOT CONNECTION")
      SocketHandler.new(connection, @routes).handle
    }
  }
}



