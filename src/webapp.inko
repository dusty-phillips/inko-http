import debug_ext::(debug)
import std::fmt::(Format, Formatter)
import std::stdio::(STDOUT)
import std::net::socket
import std::net::ip
import std::io
import std::iter::(Iter)
import std::string::(StringBuffer, ToString)
import option_ext
import uni::(Uni)
import line_reader::(LineReader)
import route::(RouteMatcher)
import http_request::(Method, HttpRequest)
import app_request::(AppRequest)
import http_response::(HttpStatus, HttpResponse)
import handler::(Handler)


class NotFoundHandler {}

impl Uni[Handler] for NotFoundHandler {
  fn pub clone_to_uni -> uni NotFoundHandler {
    recover NotFoundHandler {}
  }

  fn pub move into_referrable -> NotFoundHandler {
      self
  }
}

impl Handler for NotFoundHandler {
  fn pub handle(request: ref AppRequest) -> HttpResponse {
    let response = HttpResponse.new(HttpStatus.NOT_FOUND)
    response.body = "Not found"
    response
  }
}

class async RouteMapper {
  let @routes: Array[(RouteMatcher, Handler)]

  fn static new -> RouteMapper {
    RouteMapper {
      @routes = recover []
    }
  }

  fn pub async mut add_route(route: uni RouteMatcher, handler: uni Handler) {
    @routes.push((route, handler))
  }

  fn pub async mut match(request: uni HttpRequest, channel: Channel[uni Option[(AppRequest, Handler)]]) {
    let iter = @routes.iter
    let request = request.into_referrable
    let mut result = recover Option.None
    loop {
      match iter.next {
        case None -> break
        case Some((route, handler)) -> {
          match route.match(request) {
            case None -> nil
            case Some(app_request) -> {
              result = recover Option.Some((app_request.clone_to_uni, handler.clone_to_uni))
              break
            }
          }
        }
      }
    }
    channel.send(result)
  }
}

class async SocketHandler {
  let @connection: socket::TcpClient
  let @routes: RouteMapper

  fn static new(connection: uni socket::TcpClient, routes: RouteMapper) -> SocketHandler {
    SocketHandler {
      @connection = connection
      @routes = routes
    }
  }
  fn async mut handle {
    let http_request = match HttpRequest.parse(@connection) {
      case Ok(val) -> val
      case Error(error) -> {
        debug(error)
        match error.to_response.write(@connection) {
          case Ok(_) -> nil
          case Error(error) -> debug(error)
        }
        return
      }
    }

    let channel = Channel.new(size: 1)
    @routes.match(http_request.clone_to_uni, channel)
    let request_with_handler = channel.receive.unwrap_or((AppRequest.new(http_request), NotFoundHandler {} ))
    let app_request = request_with_handler.0
    let handler = request_with_handler.1

    let response: HttpResponse = handler.handle(app_request)
    debug(response)
    match response.write(@connection) {
      case Ok(_) -> nil
      case Error(error) -> debug(error)
    }
  }
}


class pub WebApp {
  let @listener: uni socket::TcpServer
  let @port: Int
  let @routes: RouteMapper

  # Create a  new WebApp that will connect to the given
  # address and port when `listen()` is called
  fn pub static new(address: String, port: uni Int) -> Result[WebApp,  io::Error] {

    let ip = recover ip::IpAddress.parse(address).unwrap
    let listener =  recover try socket::TcpServer.new(recover ip, port)

    Result.Ok(
      WebApp {
        @port = port
        @listener = listener
        @routes = RouteMapper.new
      }
    )
  }

  fn pub mut add_route(route: uni RouteMatcher, handler: uni Handler) {
    @routes.add_route(route, handler)
  }

  fn pub move listen() {
    STDOUT.new.print("Listening on port {@port.to_string}")
    loop {
      let connection = recover @listener.accept.unwrap
      SocketHandler.new(connection, @routes).handle
    }
  }
}



