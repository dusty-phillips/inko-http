import debug_ext::(debug)
import std::string::(ToString, StringBuffer)
import std::fmt::(Format, Formatter)
import http_request
import app_request::(AppRequest)
import http_response


trait pub RouteMatcher {
  fn pub match(request: ref http_request::HttpRequest) -> Option[AppRequest]
}


class pub FixedRoute {
  let @method: http_request::Method
  let @path: http_request::Path

  fn pub static get(path: String) -> FixedRoute {
    FixedRoute {
      @method = http_request::Method.Get
      @path = http_request::Path.new(path)
    }
  }
}
impl RouteMatcher for FixedRoute {
  fn pub match(request: ref http_request::HttpRequest) -> Option[AppRequest] {
    if (request.method != @method) {
      return Option.None
    }
    if (request.path != @path) {
      return Option.None
    }
    return Option.Some(AppRequest.new(request.clone))
  }
}

class enum ParamPathPart {
  case Fixed(String)
  case Param(String)
}

impl Format for ParamPathPart {
  fn pub fmt (formatter: mut Formatter) {
     match self {
       case Fixed(path) -> formatter.write(path)
       case Param(name) -> {
         formatter.write('{')
         formatter.write(name)
         formatter.write('}')
       }
     }
  }
}



fn parse_path_parts(path_template: String) -> Array[ParamPathPart] {
  let path_parts = []
  let iter = path_template.split('/')

  iter.each fn (part) {
    if part.starts_with?('{') and part.ends_with?('}') {
      path_parts.push(ParamPathPart.Param(part.slice_bytes(1, part.size - 2)))
    } else {
      path_parts.push(ParamPathPart.Fixed(part))
    }
  }
  path_parts
}

class pub ParamRoute {
  let @method: http_request::Method
  let @template_path_parts: Array[ParamPathPart]

  fn pub static new(method: http_request::Method, path_template: String) -> ParamRoute {
    let path_parts = parse_path_parts(path_template)
    ParamRoute {
      @method = method
      @template_path_parts = path_parts
    }
  }

  fn pub static get(path_template: String) -> ParamRoute {
    ParamRoute.new(http_request::Method.Get, path_template)
  }
}

impl RouteMatcher for ParamRoute {
  fn pub match(request: ref http_request::HttpRequest) -> Option[AppRequest] {
    if (request.method != @method) {
      return Option.None
    }
    debug(@template_path_parts)
    debug(request.path.path.split('/').to_array)

    let parts_iter = request.path.path.split('/').zip(@template_path_parts.iter)
    let app_request = AppRequest.new(request.clone)

    let mut count = 0
    loop {
      let next_match = parts_iter.next
      debug(next_match)
      match next_match {
        case None -> break
        case Some((provided, Fixed(part))) if provided != part -> return Option.None
        case Some((provided, Fixed(part))) -> nil
        case Some((provided, Param(name))) -> app_request.add_param(name, provided)
      }
      count += 1
    }

    debug(app_request.path_params)
    debug(count)
    debug(@template_path_parts.length)

    if count != @template_path_parts.length {
      return Option.None
    }

    Option.Some(app_request)
  }
}
